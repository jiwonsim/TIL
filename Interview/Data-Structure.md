# Data Structure

[Interview Question for Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner#part-1-%EC%A0%84%EC%82%B0-%EA%B8%B0%EC%B4%88) 



## 자료구조

- **Array vs Linked List** 

배열은 논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조입니다. 따라서 인덱스로 해당 원소에 접근할 수 있어 접근하는 데에 O(1)가 걸립니다. 하지만 삽입, 삭제의 경우 배열의 연속적인 특징이 깨지게 됩니다. 원하는 위치에 접근하여 삽입/삭제를 위한 추가적인 연산을 했을 때 다른 원소들을 shift 해주어야 하기 때문에 이 경우 시간 복잡도가 O(n)이 됩니다. 

연결 리스트는 배열의 한계를 해결해주는 기능을 갖고 있습니다. 각 원소가 자기 자신 다음의 어떤 원소인지만을 기억하고 있다가 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)만에 해결할 수 있습니다. 하지만 반대로 탐색하는 때에 첫번째 원소부터 다 확인해야 하기 때문에 O(n)이라는 시간이 추가적으로 발생합니다. 

- **Stack and Queue** 

Stack은 선형 자료구조의 일종으로 LIFO 구조를 가집니다. 가장 먼저 들어간 원소가 가장 나중에 나오는 방식으로 진행됩니다. 

Queue는 선형 자료구조의 일종으로 FIFO 구조를 가집니다. 먼저 들어간 원소가 가장 먼저 나옵니다. 

### Tree

트리는 비선형 자료구조로, 계층적 관계를 표현합니다. 트리를 구성하는 요소로는 노드, 간선, 루트 노드, 단말 노드, 비단말 노드가 있습니다. 

- **Binary Tree** 

이진 트리는 루트 노드를 중심으로 두 개의 서브 트리로 나누어진 형태입니다. 나뉜 두 개의 서브 트리도 모두 이진 트리여야 합니다. 여기서 특징은 노드가 하나인 경우와 노드가 하나도 없는 경우에도 이진 트리 정의에 만족한다는 점입니다. 

이진 트리는 노드의 개수가 n개고 root가 0이 아닌 1에서 시작할 때, i번째 노드에 대해서 
parent(i) = i/2
left_child(i) = 2i
right_child(i) = 2i + 1
의 인덱스 값을 가집니다. 

- **Perfact Binary Tree(포화 이진 트리)** 

모든 레벨이 꽉 찬 이진 트리를 포화 이진 트리라고 합니다. 

- **Full Binary Tree(정 이진 트리)** 

모든 노드가 0개 또는 2개의 노드를 갖는 트리를 의미합니다.

- ** Complete Binary Tree(완전 이진 트리)** 

마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 모든 노드는 가능한 한 가장 왼쪽에 있는 트리를 의미합니다. 

- ** BST (Binary Search Tree) **

이진 탐색 트리는 이진 트리의 일종입니다. 이진 탐색 트리에 데이터를 저장하기 위해서는 노드의 저장된 키가 유일하고 부모의 키가 왼쪽 자식 노드보다 크고, 오른쪽 자식 노드보다 작으며 각 서브트리도 이진 탐색 트리여야 합니다. 

이진 탐색 트리는 탐색 연산에서 O(log n)의 시간 복잡도를 가지며, 최악의 경우 O(n)의 시간 복잡도를 가집니다. 편향된 트리가 될 수 있는 경우가 있기 때문입니다. 

배열보다 많은 메모리를 사용하기 때문에 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생할 수도 있습니다. 

- **Binary Heap** 

힙은 완전 이진 트리의 구조를 띄고 있습니다. 힙에는 최대힙과 최소힙 두 종류가 있으며, 최대힙은 부모 노드가 자식노드보다 큰 힙, 최소 힙은 부모노드가 자식노드보다 작은 힙을 의미합니다. 

최대 힙에서는 루트 노드에 있는 값이 제일 크기 때문에 최대값을 찾는 데에 소요되는 연산의 시간 복잡도가 O(1)가 됩니다. (최소 힙은 그 반대) 하지만 힙의 구조를 계속 유지하기 위해서는 O(log n)의 시간 복잡도가 걸립니다. 

- **Reb-Black Tree** 



### Hash

Hash는 내부적으로 배열을 사용해 데이터를 저장하기 때문에 빠른 검색 속도를 갖습니다. 특정 값을 탐색하는 데에 데이터 고유의 인덱스로 접근하기 때문에 평균적으로 시간 복잡도는 O(1)가 됩니다. key 값을 고유한 숫자로 만들어 이를 인덱스로 사용하기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시에 다른 데이터로 채울 필요가 없으므로 연산에는 추가적인 비용이 들지 않는 구조입니다. 

- Hash Table
- Hash Map
- Hash Set
- Hash Function

해쉬 함수는 위에서 언급한 key 값을 고유한 인덱스 값으로 만들어주는 역할을 합니다. 이 해쉬 함수로 인해 변환된 데이터의 고유 숫자 값을 hashcode라고 합니다. 잘못된 해쉬 함수를 통해 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 문제가 발생하는데, 이를 Collision이라고 합니다. 

- Resolve Collision

  - Open Addressing (개방 주소 방식)

  해쉬 충돌이 발생했을 때, 다른 해쉬 버킷에 해당 자료를 삽입하는 방식입니다. 그래서 데이터를 저장할 장소를 찾아야 하는데 이 경우 비어있는 버킷을 찾지 못하고 시작 위치로 되돌아올 수도 있습니다. 

  - Separate Chaining (분리 연결 방식) 

  분리 연결 방식은 두 가지 구현 방식으로 존재합니다.

   1. 연결리스트를 이용하는 방식

      각 버킷들을 연결리스트로 만들어 충돌이 발생하면 해당 버킷의 리스트에 추가하는 방식입니다. 연결리스트의 특징대로 삽입 삭제가 간단하지만, 오버헤드가 부담이 될 수 있습니다. 

  	2. 트리를 사용하는 방식

      1번의 방식에서 연결리스트 대신 트리를 사용하는 방식입니다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수입니다. 데이터의 개수가 적다면 메모리 사용량이 많은 트리보다 연결리스트를 이용하는 것이 더 낫습니다. 

  두 방식 모두 최악의 경우 O(M)이지만, Open Addressing은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining 보다 캐시 효율이 높습니다. 그래서 데이터 개수가 충분히 적다면 Open Addressing이 더 성능이 좋습니다. 

- Resize 

### Graph 

- **Graph 구현**

1. 인접 행렬(Adjacent Matrix)

   정방 행렬을 사용하는 방법으로 해당하는 위치 값을 통해 정점 간의 연결 관계를 O(1)으로 파악할 수 있습니다. 간선의 수와 무관하게 정점^2의 공간 복잡도를 가집니다. 

2. 인접 리스트(Adjacent List) 

   정점의 인접 리스트를 확인해봐야 하기 때문에 정점이 서로 연결되어 있는지 확인하는 데에 오래 걸립니다. 공간 복잡도는 정점+간선이 됩니다. 

- **Graph 탐색**

1. 깊이 우선 탐색(Depth First Search: DFS)

   그래프에서 하나의 정점으로부터 연결된 정점을 우선적으로 탐색하는 방식입니다. 연결할 수 있는 정점이 존재하는 한 탐색을 계속합니다. 더이상 연결된 정점이 없으면 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점을 찾습니다. 재귀적으로 찾을 수도 있고 Stack을 이용할 수 있습니다. 

2. 너비 우선 탐색(Breadth First Search: BFS) 

   그래프에서 하나의 정점으로부터 연결되어 있는 모든 정점을 우선적으로 탐색하는 방법입니다. 이 경우에는 Queue를 이용해 탐색한 정점과 연결된 모든 정점을 enqueue합니다. 그렇게 되면 정점을 방문한 순서대로 dequeue하며 탐색할 수 있습니다. 너비 우선 탐색을 이용하게 되면 최단 경로를 찾을 수 있습니다. 

- **Minimum Spanning Tree**

  Spanning tree는 그래프의 모든 정점이 cycle 없이 연결된 형태를 의미합니다. Minimum spanning tree는 간선의 가중치의 합이 최소인 spanning tree를 말합니다. 

  - **Kruskal algorithm**

  가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘입니다. 그렇기 때문에 간선을 최대한 덜 쓰게 되어, 간선의 개수는 (노드의 개수 - 1)이 됩니다. 

  간선의 가중치를 오름차순으로 정렬한 후에 가장 작은 가중치에 해당하는 간선을 우선적으로 탐색합니다. 그리고 간선을 추가했을 때 cycle이 발생하지 않을 때에만 추가할 수 있습니다. 

  cycle의 발생 여부는 Union-Find 알고리즘을 그대로 적용하면 됩니다. 

  - **Prim alogrithm **

  초기화 과정에서 한 개의 정점으로 이루어진 초기 그래프 A를 구성하고, 하나의 정점에 대해 외부에 있는 정점 간의 간선 중 가장 작은 가중치의 간선을 통해 연결되는 정점을 추가합니다. 오로지 간선의 가중치를 기준으로 연결하게 되며, 이로 인해 간선은 그래프 A에 포함됩니다.

