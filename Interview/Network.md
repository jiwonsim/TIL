# Network



[Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network)
[현우의 개발노트 - 네트워크 통신 면접](https://hyeonu1258.github.io/2018/03/10/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%86%B5%EC%8B%A0%20%EB%A9%B4%EC%A0%91/)
[@hygoogi/기술면접-준비하기](https://velog.io/@hygoogi/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0)



###HTTP 메소드 중 GET, POST 비교 

HTTP 메소드는 HTTP 프로토콜을 이용해 서버에 무엇인가를 요청할 때 사용하는 방식입니다. 

GET 방식은 요청하는 데이터가 `HTTP Request Message`의 Header 부분의 URL에 담겨 전송됩니다. `?` 뒤에 데이터를 붙여 요청을 보내기 때문에 전송할 수 있는 데이터의 크기가 제한적입니다. 또한 데이터가 URL에 모두 노출되기 때문에 보안이 필요한 경우에는 GET 메소드를 사용하지 않습니다. 

POST 방식은 요청을 할 때 `HTTP Message`의 Body 부분에 데이터가 담겨서 전송됩니다. 따라서 데이터 크기가 GET 방식보다 크고 URI에 노출되지 않아 보안면에서 조금 더 낫습니다. (사실상 암호화를 하지 않기 때문에 보안적인 부분은 GET 방식과 크게 다르지 않습니다.)

### OSI 7계층 

응용 - 표현 - 세션 - 전송 - 네트워크 - 데이터링크 - 물리 

물리 계층은 <u>비트열을 전기 신호로 변환</u>하여 통신 케이블로 데이터를 전송하는 역할을 합니다. 이 계층에서는 데이터의 내용이나 에러에는 전혀 관여하지 않고 전달하는 역할만 수행합니다. 

데이터링크 계층은 랜에서 데이터를 주고 받기 위해서 거치는 구간으로, <u>네트워크 장비 간에 신호를 주고 받는 규칙을 결정</u>합니다. 주로 <u>이더넷</u>을 이용하며, 랜 카드에 표기된 <u>MAC(Media Access Control) 주소</u>를 이용해 주소 값을 설정합니다. 이 계층에서의 데이터 전송 단위를 프레임이라고 합니다.

네트워크 계층은 <u>데이터를 서로 다른 네트워크에 있는 목적지로 전송</u>하는 역할을 합니다. 이 계층에서 다른 네트워크로 데이터를 전송하기 위해서 <u>라우터</u>라는 네트워크 장비를 사용합니다. 라우터를 이용해 데이터의 목적지를 정하며, 어떤 경로로 가야 하는지 결정할 수가 있는데, 이때 네트워크를 식별할 수 있는 주소인 <u>IP 주소</u>를 이용합니다. 

전송 계층은 <u>오류를 점검하는 기능을 수행하여 오류가 발생하면 데이터를 재전송하라고 요청</u>합니다. 전송 계층에는 신뢰할 수 있고 정확한 데이터를 전달하는 연결형 통신(TCP 프로토콜)과 효율적으로 데이터를 전달하는 방식인 비연결형 통신(UDP 프로토콜)이 있습니다. 

세션 계층은 데이터가 통신하기 위한 논리적인 연결 구조를 만들거나 종료하는 역할을 합니다. 

표현 계층은 상이한 응용 프로세스의 독립성을 제공하고 암호화하는 역할을 합니다. 다른 시스템의 애플리케이션에서 온 정보를 읽을 수 있도록 바꿔준다는 것을 의미합니다. 

응용 계층은 최종 목적지로 사용자와 가장 가까이에 있는 계층입니다. 대표적으로 HTTP, FTP 프로토콜이 있습니다. 우리가 사용하는 브라우저나 메일 프로그램은 프로토콜을 보다 쉽게 사용하도록 만들어주는 응용 프로그램입니다. 

###TCP와 UDP 비교

UDP(User Datagram Protocol)는 비연결형 프로토콜로 흐름 제어, 오류 제어를 하지 않고 손상된 세그먼트에 대한 수신에 대한 재전송을 하지 않습니다. UDP가 하는 것은 포트들을 사용해 IP 프로토콜에 인터페이스를 제공하는 것입니다. 짧은 요청과 짧은 응답을 기대하는 경우에 UDP를 사용할 수 있습니다. 요청/응답에 손실이 있다면 클라이언트는 타임 아웃이 되어 다시 시도할 수 있게 됩니다. UDP를 사용하게 되면 코드가 간결해지고 TCP처럼 초기설정에서 요구되는 프로토콜보다 적은 메시지가 요구된다는 장점이 있습니다. 

TCP(Transmission Control Protocol)는 신뢰성이 없는 인터넷을 통해 종단 간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계되었습니다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어지며, 연결 설정은 3-way handshake를 통해 이루어집니다. 모든 TCP 연결은 전이중 방식으로, 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미합니다. TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않습니다. 

###TCP 3-way handshaking

TCP 프로토콜은 신뢰성을 보장하기 때문에 클라이언트가 접속을 요청하고 수락하는 과정이 필요합니다. 그 과정을 3-way handshaking이라고 합니다. 

전송 계층에서 TCP 헤더가 붙는데, 그 중에 코드 비트가 있습니다. 코드 비트는 6비트로 이루어진 데이터로, 연결 제어 정보를 기록하는 역할을 합니다. 거기에 SYN과 ACK, FIN 비트를 이용해서 연결을 제어합니다. SYN는 연결 요청, ACK는 확인 응답, FIN은 연결 종료를 의미합니다. 

3-way handshaking은 클라이언트가 서버로부터 연결을 요청하기 위해 SYN 비트를 활성화하여 패킷을 전송합니다. 그러면 서버는 클라이언트로 SYN과 ACK 비트를 활성화하여 클라이언트의 요청을 수락합니다. 클라이언트는 ACK 비트를 활성화하여 서버로 보내면 연결이 성립됩니다. 

연결을 해제하는 방법으로는 4-way handshaking이 있습니다. 먼저 클라이언트가 연결을 종료하겠다는 의미로 FIN 비트를 활성화하여 서버로 전송합니다. 서버는 확인 메시지로 ACK 비트를 활성화하여 전송하고, 데이터를 모두 보낼 때까지 Time out 합니다. 데이터를 모두 보내고 나면 통신이 끝났다는 의미로 서버는 클라이언트로 FIN 비트를 활성화하여 보냅니다. 그러면 클라이언트는 확인했다는 의미로 ACK 비트를 활성화하여 보내고, 서버는 소켓 연결을 close 합니다. 

TCP 헤더에는 Sequence Number가 포함되어 있는데, 3-way handshaking을 할 때 SYN 패킷을 보내면서 Sequence Number에 난수를 넣어 보냅니다. 이것은 연결을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하기 때문에 재사용하는 경우가 발생하고, 이렇게 되면 패킷을 구분하는 데에 어려움이 있기 때문입니다. 그래서 난수를 이용해서 이전의 연결과 다른 패킷이라는 것을 명시적으로 알려주는 것입니다. 

###DNS Round Robin 방식



###웹 통신의 큰 흐름



###HTTP와 HTTPS 

HTTP는 하이퍼커넥트 전송 프로토콜의 약자로, 서로 다른 시스템들 사이에서 통신을 주고 받게 해주는 기초적인 프로토콜입니다. 인터넷 초기에 웹 사이트에서 기본적으로 사용됐던 프로토콜이라고 할 수 있습니다. 일반 HTTP 프로토콜은 평문 통신이기 때문에 보안에 취약하고 통신 상대를 확인하지 않기 때문에 위장이 가능합니다. 

HTTPS는 그런 HTTP에 Secure가 붙은 프로토콜입니다. HTTPS는 애플리케이션의 새로운 프로토콜이 아닌, 소켓 부분을 SSL(Secure Socket Layer)/TSL(Transport Layer Security)라는 프로토콜로 대체하는 것입니다. HTTP가 원래 TCP와 직접 통신을 했다면, HTTPS는 SSL과 통신하고 SSL이 TCP와 통신합니다. SSL을 사용하면 서버와 브라우저 간에 안전하게 암호화된 연결을 만들 수 있게 해주고, 서버 브라우저가 민감한 정보를 주고 받을 때 도난 당하는 것을 막아주는 역할을 합니다. SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하기 때문에 전송된 데이터를 중간에 훔쳐가더라도 해독할 수가 없습니다. 

HTTPS를 사용하게 되면 사용자에게 신뢰성 있는 사이트로 인정 받게 되지만, 평문 통신에 비해 암호화 통신은 CPU나 메모리와 같은 리소스가 많이 필요합니다. 통신할 때마다 암호화를 하게 되면 많은 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 줄어들게 되어, 민감한 정보를 다룰 때에만 HTTPS에 의한 암호화 통신을 사용하게 됩니다. 

하지만 이건 옛말이고 HTTP 2.0부터는 HTTP보다 HTTPS가 모자람이 없다고 합니다. CPU의 기술이 보다 더 빨라지고 HTTPS 인증서 비용도 무료로 발급해주는 기관이 생겨 HTTPS의 비용이 낮아졌습니다. 이것은 HTTP 2를 지원하는 브라우저의 경우에 해당하는 것입니다. 그래서 대체적으로 HTTP와 HTTPS 간의 구도가 아닌 HTTP 1과 HTTP 2 의 구도로 보는 것이 적합합니다. 

### SSL 

SSL은 인터넷 상의 데이터를 안전하게 전송하기 위한 인터넷 암호화 통신 프로토콜으로, 표현 계층에 속합니다. RSA의 비대칭키 암호화 시스템을 이용하고 있습니다. 응용 계층의 프로토콜들은 외부로 보내는 데이터를 TCP나 UDP가 아닌 SSL에 보내게 됩니다. SSL은 데이터를 암호화해 TCP로 보내어 외부 인터넷으로 전달하게 됩니다. 전달 받을 때도 TCP로부터 받은 데이터를 복호화해 응용 계층으로 전달하게 됩니다. 

### 공개키 암호화

SSL은 대칭키와 공개키 방식 두 암호화 방식을 사용합니다. 

대칭키는 동일한 키로 암호화 복호화를 같이 할 수 있는 방식의 암호화 기법입니다. 이렇게 되면 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다는 단점이 발생합니다. 만약 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화할 수 있기 때문에 암호가 무용지물이 되기 때문입니다.

공개키는 이러한 대칭키의 한계를 해결해줍니다. 공개키 방식은 두 개의 키 A와 B를 갖게 되는데, A 키로 암호화를 하면 B 키로 복호화를 할 수 있습니다. B 키로 암호화하면 A 키로 복호화할 수 있습니다. 이 방식을 착안하여 두 개의 키 중에 하나를 비공개 키로 하고, 나머지를 공개 키로 지정합니다. 비공개 키는 자신만 갖고 있고 공개키는 타인에게 전송합니다. 공개키를 제공 받은 타인은 공개키를 이용해 정보를 암호화하고 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송합니다. 비공개키의 소유자는 이 키를 이용해 암호화된 정보를 복호화합니다. 이 과정에서 공개키가 유출된다고 해도 비공개키를 모르면 정보를 복원할 수 없기 때문에 안전합니다. 

SSL은 공개키와 대칭키의 장점을 혼합한 방법을 사용합니다. 클라이언트에서 생성한 대칭키를 서버의 공개키를 이용해 암호화해서 보냅니다. 그 후에 데이터를 주고 받는 과정에서 대칭키를 이용합니다. 

### HTTP keepalive

Keepalive는 두 호스트 간의 통신 중 일정시간동안 패킷 교환이 없을 때 자동으로 연결이 해지되는 것을 막기 위해 주기적으로 패킷을 보내는 것을 의미합니다. 

HTTP는 비연결형 통신이기 때문에 커넥션을 유지하지 않습니다. 그래서 재요청을 하기 위해서는 다시 설정해야 하기 때문에 비용이 많이 듭니다. 이것을 해결하기 위해 keepalive timeout 내에 재요청을 하면 열려있는 커넥션을 통해 전송하는 keepalive 기능이 생겼습니다. 하지만 keepalive timeout을 너무 오래 설정하면 다른 사용자가 연결을 못하게 되기 때문에 사용자가 적은 환경에서 사용하는 것을 좋습니다.

TCP에서도 Keepalive가 일어납니다. 패킷 교환이 없는 두 지점에 대해 payload가 없는 패킷을 주기적으로 보내게 됩니다. 종단 시스템 중 하나가 다운될 때 다른쪽 시스템만 열린 연결 상태를 정리하기 위해 사용합니다. 

